<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>migration/migrations/2020-01-15.js - SNJS Documentation</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountSyncOperation.html">AccountSyncOperation</a></li><li><a href="AccountSyncResponseResolver.html">AccountSyncResponseResolver</a></li><li><a href="DeviceInterface.html">DeviceInterface</a></li><li><a href="HistorySession.html">HistorySession</a></li><li><a href="ItemsKeyManager.html">ItemsKeyManager</a><ul class='methods'><li data-type='method'><a href="ItemsKeyManager.html#addItemsKeyChangeObserver">addItemsKeyChangeObserver</a></li><li data-type='method'><a href="ItemsKeyManager.html#createNewDefaultItemsKey">createNewDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#defaultItemsKeyForItemVersion">defaultItemsKeyForItemVersion</a></li><li data-type='method'><a href="ItemsKeyManager.html#getDefaultItemsKey">getDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#handleDownloadFirstSyncCompletion">handleDownloadFirstSyncCompletion</a></li><li data-type='method'><a href="ItemsKeyManager.html#reencryptItemsKeys">reencryptItemsKeys</a></li><li data-type='method'><a href="ItemsKeyManager.html#setKeyManager">setKeyManager</a></li></ul></li><li><a href="OfflineSyncOperation_OfflineSyncOperation.html">OfflineSyncOperation</a></li><li><a href="PayloadCollection.html">PayloadCollection</a></li><li><a href="PayloadCollectionSet_PayloadCollectionSet.html">PayloadCollectionSet</a></li><li><a href="PayloadsDelta.html">PayloadsDelta</a></li><li><a href="PurePayload.html">PurePayload</a></li><li><a href="SFItem.html">SFItem</a><ul class='methods'><li data-type='method'><a href="SFItem.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SFItem.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SFItem.html#initUUID">initUUID</a></li><li data-type='method'><a href="SFItem.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SFItem.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SFItem.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SFItem.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNActionsService.html">SNActionsService</a><ul class='methods'><li data-type='method'><a href="SNActionsService.html#loadExtensionInContextOfItem">loadExtensionInContextOfItem</a></li></ul></li><li><a href="SNAlertService.html">SNAlertService</a></li><li><a href="SNApplication.html">SNApplication</a><ul class='methods'><li data-type='method'><a href="SNApplication.html#addEventObserver">addEventObserver</a></li><li data-type='method'><a href="SNApplication.html#addSingleEventObserver">addSingleEventObserver</a></li><li data-type='method'><a href="SNApplication.html#changeDeviceInterface">changeDeviceInterface</a></li><li data-type='method'><a href="SNApplication.html#changePasscode">changePasscode</a></li><li data-type='method'><a href="SNApplication.html#changePassword">changePassword</a></li><li data-type='method'><a href="SNApplication.html#clearDatabase">clearDatabase</a></li><li data-type='method'><a href="SNApplication.html#createItem">createItem</a></li><li data-type='method'><a href="SNApplication.html#deinit">deinit</a></li><li data-type='method'><a href="SNApplication.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="SNApplication.html#deleteItemLocally">deleteItemLocally</a></li><li data-type='method'><a href="SNApplication.html#emptyTrash">emptyTrash</a></li><li data-type='method'><a href="SNApplication.html#findItem">findItem</a></li><li data-type='method'><a href="SNApplication.html#findItems">findItems</a></li><li data-type='method'><a href="SNApplication.html#findOrCreateTag">findOrCreateTag</a></li><li data-type='method'><a href="SNApplication.html#findTag">findTag</a></li><li data-type='method'><a href="SNApplication.html#generateUuid">generateUuid</a></li><li data-type='method'><a href="SNApplication.html#getDisplayableItems">getDisplayableItems</a></li><li data-type='method'><a href="SNApplication.html#getHost">getHost</a></li><li data-type='method'><a href="SNApplication.html#getItems">getItems</a></li><li data-type='method'><a href="SNApplication.html#getNoteCount">getNoteCount</a></li><li data-type='method'><a href="SNApplication.html#getNotesMatchingSmartTag">getNotesMatchingSmartTag</a></li><li data-type='method'><a href="SNApplication.html#getSmartTags">getSmartTags</a></li><li data-type='method'><a href="SNApplication.html#getSyncStatus">getSyncStatus</a></li><li data-type='method'><a href="SNApplication.html#getTrashedItems">getTrashedItems</a></li><li data-type='method'><a href="SNApplication.html#getUser">getUser</a></li><li data-type='method'><a href="SNApplication.html#getUserVersion">getUserVersion</a></li><li data-type='method'><a href="SNApplication.html#getValue">getValue</a></li><li data-type='method'><a href="SNApplication.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNApplication.html#importData">importData</a></li><li data-type='method'><a href="SNApplication.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNApplication.html#isEphemeralSession">isEphemeralSession</a></li><li data-type='method'><a href="SNApplication.html#isLocked">isLocked</a></li><li data-type='method'><a href="SNApplication.html#isStarted">isStarted</a></li><li data-type='method'><a href="SNApplication.html#launch">launch</a></li><li data-type='method'><a href="SNApplication.html#lock">lock</a></li><li data-type='method'><a href="SNApplication.html#mergeItem">mergeItem</a></li><li data-type='method'><a href="SNApplication.html#noAccount">noAccount</a></li><li data-type='method'><a href="SNApplication.html#prepareForLaunch">prepareForLaunch</a></li><li data-type='method'><a href="SNApplication.html#register">register</a></li><li data-type='method'><a href="SNApplication.html#registerService">registerService</a></li><li data-type='method'><a href="SNApplication.html#removePasscode">removePasscode</a></li><li data-type='method'><a href="SNApplication.html#removeValue">removeValue</a></li><li data-type='method'><a href="SNApplication.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNApplication.html#restart">restart</a></li><li data-type='method'><a href="SNApplication.html#saveItem">saveItem</a></li><li data-type='method'><a href="SNApplication.html#saveItems">saveItems</a></li><li data-type='method'><a href="SNApplication.html#savePayload">savePayload</a></li><li data-type='method'><a href="SNApplication.html#setHost">setHost</a></li><li data-type='method'><a href="SNApplication.html#setItemNeedsSync">setItemNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setItemsNeedsSync">setItemsNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setPasscode">setPasscode</a></li><li data-type='method'><a href="SNApplication.html#setStorageEncryptionPolicy">setStorageEncryptionPolicy</a></li><li data-type='method'><a href="SNApplication.html#setValue">setValue</a></li><li data-type='method'><a href="SNApplication.html#signIn">signIn</a></li><li data-type='method'><a href="SNApplication.html#signOut">signOut</a></li><li data-type='method'><a href="SNApplication.html#streamItems">streamItems</a></li><li data-type='method'><a href="SNApplication.html#sync">sync</a></li><li data-type='method'><a href="SNApplication.html#validateAccountPassword">validateAccountPassword</a></li></ul></li><li><a href="SNComponentManager.html">SNComponentManager</a><ul class='methods'><li data-type='method'><a href="SNComponentManager.html#deinit">deinit</a></li><li data-type='method'><a href="SNComponentManager.html#registerComponentWindow">registerComponentWindow</a></li></ul></li><li><a href="SNEditor.html">SNEditor</a></li><li><a href="SNHistoryManager.html">SNHistoryManager</a></li><li><a href="SNHttpService.html">SNHttpService</a></li><li><a href="SNKeyManager.html">SNKeyManager</a><ul class='methods'><li data-type='method'><a href="SNKeyManager.html#clearLocalKeyState">clearLocalKeyState</a></li><li data-type='method'><a href="SNKeyManager.html#contentTypeUsesRootKeyEncryption">contentTypeUsesRootKeyEncryption</a></li><li data-type='method'><a href="SNKeyManager.html#getAccountKeyParams">getAccountKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKey">getRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyParams">getRootKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyWrapperKeyParams">getRootKeyWrapperKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNKeyManager.html#hasRootKeyWrapper">hasRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForDecryptionOfPayload">keyToUseForDecryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForEncryptionOfPayload">keyToUseForEncryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="SNKeyManager.html#removeRootKeyWrapper">removeRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#rootKeyNeedsUnwrapping">rootKeyNeedsUnwrapping</a></li><li data-type='method'><a href="SNKeyManager.html#setDeviceInterface">setDeviceInterface</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKey">setNewRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKeyWrapper">setNewRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#unwrapRootKey">unwrapRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#validateAccountPassword">validateAccountPassword</a></li><li data-type='method'><a href="SNKeyManager.html#validatePasscode">validatePasscode</a></li><li data-type='method'><a href="SNKeyManager.html#validateWrappingKey">validateWrappingKey</a></li></ul></li><li><a href="SNMaxItemPayload.html">SNMaxItemPayload</a></li><li><a href="SNMigrationService.html">SNMigrationService</a><ul class='methods'><li data-type='method'><a href="SNMigrationService.html#handleApplicationStage">handleApplicationStage</a></li></ul></li><li><a href="SNModelManager.html">SNModelManager</a><ul class='methods'><li data-type='method'><a href="SNModelManager.html#addItem">addItem</a></li><li data-type='method'><a href="SNModelManager.html#createItem">createItem</a></li><li data-type='method'><a href="SNModelManager.html#getMasterCollection">getMasterCollection</a></li><li data-type='method'><a href="SNModelManager.html#insertItem">insertItem</a></li><li data-type='method'><a href="SNModelManager.html#insertItems">insertItems</a></li><li data-type='method'><a href="SNModelManager.html#setItemDirty">setItemDirty</a></li><li data-type='method'><a href="SNModelManager.html#setItemProperties">setItemProperties</a></li></ul></li><li><a href="SNNote.html">SNNote</a><ul class='methods'><li data-type='method'><a href="SNNote.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SNNote.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SNNote.html#initUUID">initUUID</a></li><li data-type='method'><a href="SNNote.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SNNote.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SNNote.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SNNote.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNNoteSFItem.html">SFItem</a></li><li><a href="SNNoteSNNoteSFItem.html">SFItem</a></li><li><a href="SNPrivilegesService.html">SNPrivilegesService</a><ul class='methods'><li data-type='method'><a href="SNPrivilegesService.html#actionRequiresPrivilege">actionRequiresPrivilege</a></li><li data-type='method'><a href="SNPrivilegesService.html#netCredentialsForAction">netCredentialsForAction</a></li></ul></li><li><a href="SNProtocolOperator.html">SNProtocolOperator</a><ul class='methods'><li data-type='method'><a href="SNProtocolOperator.html#createItemsKey">createItemsKey</a></li><li data-type='method'><a href="SNProtocolOperator.html#generateNewItemsKeyContent">generateNewItemsKeyContent</a></li></ul></li><li><a href="SNProtocolService.html">SNProtocolService</a><ul class='methods'><li data-type='method'><a href="SNProtocolService.html#compareRootKeys">compareRootKeys</a></li><li data-type='method'><a href="SNProtocolService.html#createBackupFile">createBackupFile</a></li><li data-type='method'><a href="SNProtocolService.html#decryptErroredItems">decryptErroredItems</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByDecryptingPayload">payloadByDecryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByEncryptingPayload">payloadByEncryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#setKeyManager">setKeyManager</a></li><li data-type='method'><a href="SNProtocolService.html#supportedVersions">supportedVersions</a></li></ul></li><li><a href="SNRootKey.html">SNRootKey</a><ul class='methods'><li data-type='method'><a href="SNRootKey.html#compare">compare</a></li><li data-type='method'><a href="SNRootKey.html#getPersistableValue">getPersistableValue</a></li></ul></li><li><a href="SNRootKeyParams.html">SNRootKeyParams</a><ul class='methods'><li data-type='method'><a href="SNRootKeyParams.html#getPortableValue">getPortableValue</a></li></ul></li><li><a href="SNSavedServerItemPayload.html">SNSavedServerItemPayload</a></li><li><a href="SNSessionManager.html">SNSessionManager</a></li><li><a href="SNSingletonManager.html">SNSingletonManager</a><ul class='methods'><li data-type='method'><a href="SNSingletonManager.html#addObservers">addObservers</a></li><li data-type='method'><a href="SNSingletonManager.html#registerPredicate">registerPredicate</a></li></ul></li><li><a href="SNStorageService.html">SNStorageService</a><ul class='methods'><li data-type='method'><a href="SNStorageService.html#canDecryptWithKey">canDecryptWithKey</a></li><li data-type='method'><a href="SNStorageService.html#clearValues">clearValues</a></li><li data-type='method'><a href="SNStorageService.html#decryptStorage">decryptStorage</a></li><li data-type='method'><a href="SNStorageService.html#generatePersistenceValue">generatePersistenceValue</a></li><li data-type='method'><a href="SNStorageService.html#getAllRawPayloads">getAllRawPayloads</a></li><li data-type='method'><a href="SNStorageService.html#getPersistenceKey">getPersistenceKey</a></li><li data-type='method'><a href="SNStorageService.html#handleApplicationStage">handleApplicationStage</a></li><li data-type='method'><a href="SNStorageService.html#isStorageWrapped">isStorageWrapped</a></li><li data-type='method'><a href="SNStorageService.html#setInitialValues">setInitialValues</a></li></ul></li><li><a href="SNSyncService.html">SNSyncService</a><ul class='methods'><li data-type='method'><a href="SNSyncService.html#computeDataIntegrityHash">computeDataIntegrityHash</a></li><li data-type='method'><a href="SNSyncService.html#getDatabasePayloads">getDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#handleNeverSyncedDeleted">handleNeverSyncedDeleted</a></li><li data-type='method'><a href="SNSyncService.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNSyncService.html#loadDatabasePayloads">loadDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#markAllItemsAsNeedingSync">markAllItemsAsNeedingSync</a></li><li data-type='method'><a href="SNSyncService.html#payloadsByPreparingForServer">payloadsByPreparingForServer</a></li><li data-type='method'><a href="SNSyncService.html#popPayloadsNeedingPreSyncSave">popPayloadsNeedingPreSyncSave</a></li><li data-type='method'><a href="SNSyncService.html#popSpawnQueue">popSpawnQueue</a></li><li data-type='method'><a href="SNSyncService.html#repersistAllItems">repersistAllItems</a></li><li data-type='method'><a href="SNSyncService.html#resetSyncState">resetSyncState</a></li><li data-type='method'><a href="SNSyncService.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNSyncService.html#sync">sync</a></li><li data-type='method'><a href="SNSyncService.html#ut_beginLatencySimulator">ut_beginLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_endLatencySimulator">ut_endLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_setDatabaseLoaded">ut_setDatabaseLoaded</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayByDifference">arrayByDifference</a></li><li><a href="global.html#arrayByRemovingFromIndex">arrayByRemovingFromIndex</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#deepMerge">deepMerge</a></li><li><a href="global.html#DEFAULT_AUTO_SYNC_INTERVAL">DEFAULT_AUTO_SYNC_INTERVAL</a></li><li><a href="global.html#DEFAULT_ITEM_REVISIONS_THRESHOLD">DEFAULT_ITEM_REVISIONS_THRESHOLD</a></li><li><a href="global.html#extendArray">extendArray</a></li><li><a href="global.html#intentRequiresEncryption">intentRequiresEncryption</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_NONE">KEY_MODE_ROOT_KEY_NONE</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_ONLY">KEY_MODE_ROOT_KEY_ONLY</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_PLUS_WRAPPER">KEY_MODE_ROOT_KEY_PLUS_WRAPPER</a></li><li><a href="global.html#KEY_MODE_WRAPPER_ONLY">KEY_MODE_WRAPPER_ONLY</a></li><li><a href="global.html#LARGE_ENTRY_DELTA_THRESHOLD">LARGE_ENTRY_DELTA_THRESHOLD</a></li><li><a href="global.html#LAST_NONROOT_ITEMS_KEY_VERSION">LAST_NONROOT_ITEMS_KEY_VERSION</a></li><li><a href="global.html#lastElement">lastElement</a></li><li><a href="global.html#omitByCopy">omitByCopy</a></li><li><a href="global.html#PayloadsByAlternatingUuid">PayloadsByAlternatingUuid</a></li><li><a href="global.html#PayloadsByDuplicating">PayloadsByDuplicating</a></li><li><a href="global.html#pickByCopy">pickByCopy</a></li><li><a href="global.html#RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP">RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#removeFromIndex">removeFromIndex</a></li><li><a href="global.html#SortPayloadsByRecentAndContentPriority">SortPayloadsByRecentAndContentPriority</a></li><li><a href="global.html#StorageEncryptionPolicies">StorageEncryptionPolicies</a></li><li><a href="global.html#StoragePersistencePolicies">StoragePersistencePolicies</a></li><li><a href="global.html#StorageValueModes">StorageValueModes</a></li><li><a href="global.html#subtractFromArray">subtractFromArray</a></li><li><a href="global.html#ValueModesKeys">ValueModesKeys</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">migration/migrations/2020-01-15.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Migration } from '@Lib/migration/migrations/migration';
import {
  isEnvironmentWebOrDesktop,
  isEnvironmentMobile,
  Challenges,
  StorageKeys,
  namespacedKey,
  ApplicationStages
} from '@Lib';
import { CopyPayload, CreateMaxPayloadFromAnyObject } from '@Payloads';
import { Copy, isNullOrUndefined } from '@Lib/utils';
import { ProtocolVersions, EncryptionIntents, SNRootKey } from '@Protocol';
import { SNItemsKey, ContentTypes } from '@Models';
import { SNStorageService } from '@Services';
import { Uuid } from '@Lib/uuid';
import { ValueModesKeys } from '@Services/storage_service';

const LEGACY_WEB_PASSCODE_PARAMS_KEY = 'offlineParams';
const LEGACY_MOBILE_PASSCODE_PARAMS_KEY = 'pc_params';
const LEGACY_ALL_ACCOUNT_KEY_PARAMS_KEY = 'auth_params';
const LEGACY_WEB_ENCRYPTED_STORAGE_KEY = 'encryptedStorage';
const LEGACY_MOBILE_WRAPPED_ROOT_KEY_KEY = 'encrypted_account_keys';

export class Migration20200115 extends Migration {

  static timestamp() {
    return (new Date('2020-01-15').getTime());
  }

  /** @access protected */
  registerStageHandlers() {
    this.registerStageHandler(ApplicationStages.PreparingForLaunch_0, async () => {
      if (isEnvironmentWebOrDesktop(this.application.environment)) {
        return this.migrateStorageStructureForWebDesktop();
      } else if (isEnvironmentMobile(this.application.environment)) {
        return this.migrateStorageStructureForMobile();
      }
    });
    this.registerStageHandler(ApplicationStages.StorageDecrypted_09, async () => {
      await this.migrateArbitraryRawStorageToManagedStorageAllPlatforms();
    });
    this.registerStageHandler(ApplicationStages.LoadingDatabase_11, async () => {
      await this.createDefaultItemsKeyForAllPlatforms();
      this.markDone();
    });
  }

  /**
   * Web
   * Migrates legacy storage strucutre into new managed format.
   * If encrypted storage exists, we need to first decrypt it with the passcode.
   * Then extract the account key from it. Then, encrypt storage with the
   * account key. Then encrypt the account key with the passcode and store it
   * within the new storage format.
   *
   * Generate note: We do not use the keychain if passcode is available.
   * @access private
   */
  async migrateStorageStructureForWebDesktop() {
    const deviceInterface = this.application.deviceInterface;
    const newStorageRawStructure = {
      [ValueModesKeys.Wrapped]: null,
      [ValueModesKeys.Unwrapped]: {},
      [ValueModesKeys.Nonwrapped]: {}
    };
    const rawAccountKeyParams = await deviceInterface.getJsonParsedStorageValue(
      LEGACY_ALL_ACCOUNT_KEY_PARAMS_KEY
    );
    /** Could be null if no account, or if account and storage is encrypted */
    if (rawAccountKeyParams) {
      newStorageRawStructure.nonwrapped[StorageKeys.RootKeyParams] = rawAccountKeyParams;
    }
    const encryptedStorage = await deviceInterface.getJsonParsedStorageValue(
      LEGACY_WEB_ENCRYPTED_STORAGE_KEY
    );
    if (encryptedStorage) {
      const encryptedStoragePayload = CreateMaxPayloadFromAnyObject({
        object: encryptedStorage
      });
      const passcodeResult = await this.webDesktopHelperGetPasscodeKeyAndDecryptEncryptedStorage(
        encryptedStoragePayload
      );
      const passcodeKey = passcodeResult.key;
      const decryptedStoragePayload = passcodeResult.decryptedStoragePayload;
      const passcodeParams = passcodeResult.keyParams;
      newStorageRawStructure.nonwrapped[
        StorageKeys.RootKeyWrapperKeyParams
      ] = passcodeParams.getPortableValue();
      const storageValueStore = Copy(decryptedStoragePayload.content.storage);
      /** Store previously encrypted auth_params into new nonwrapped key */
      newStorageRawStructure.nonwrapped[
        StorageKeys.RootKeyParams
      ] = storageValueStore[
        LEGACY_ALL_ACCOUNT_KEY_PARAMS_KEY
      ];

      let keyToEncryptStorageWith = passcodeKey;
      /** Extract account key (mk, pw, ak) if it exists */
      const hasAccountKeys = !isNullOrUndefined(storageValueStore.mk);
      if (hasAccountKeys) {
        const { accountKey, wrappedKey } = await this.webDesktopHelperExtractAndWrapAccountKeysFromValueStore(
          passcodeKey,
          storageValueStore
        );
        keyToEncryptStorageWith = accountKey;
        newStorageRawStructure.nonwrapped[StorageKeys.WrappedRootKey] = wrappedKey;
      }
      /** Encrypt storage with proper key */
      newStorageRawStructure.wrapped = await this.webDesktopHelperEncryptStorage(
        keyToEncryptStorageWith,
        decryptedStoragePayload,
        storageValueStore
      );
    } else {
      /** 
       * No encrypted storage, take account keys out of raw storage 
       * and place them in the keychain. */
      const ak = await this.application.deviceInterface.getRawStorageValue('ak');
      const version = !isNullOrUndefined(ak)
        ? ProtocolVersions.V003
        : ProtocolVersions.V002;
      const accountKey = await SNRootKey.Create({
        content: {
          masterKey: await this.application.deviceInterface.getRawStorageValue('mk'),
          serverPassword: await this.application.deviceInterface.getRawStorageValue('pw'),
          dataAuthenticationKey: ak,
          version: version
        }
      });
      await this.application.deviceInterface.setKeychainValue(
        accountKey.getPersistableValue()
      );
    }

    /** Persist storage under new key and structure */
    await this.allPlatformHelperSetStorageStructure(newStorageRawStructure);
  }

  /**
   * Helper
   * All platforms
   */
  async allPlatformHelperSetStorageStructure(rawStructure) {
    const newStructure = SNStorageService.defaultValuesObject(
      rawStructure
    );
    newStructure[ValueModesKeys.Unwrapped] = null;
    await this.application.deviceInterface.setRawStorageValue(
      namespacedKey(this.application.namespace, StorageKeys.StorageObject),
      JSON.stringify(newStructure)
    );
  }

  /**
   * Helper
   * Web/desktop only
   */
  async webDesktopHelperGetPasscodeKeyAndDecryptEncryptedStorage(encryptedPayload) {
    const rawPasscodeParams = await this.application.deviceInterface
      .getJsonParsedStorageValue(
        LEGACY_WEB_PASSCODE_PARAMS_KEY
      );
    const passcodeParams = this.application.protocolService
      .createKeyParams(rawPasscodeParams);
    /** Decrypt it with the passcode */
    let decryptedStoragePayload = { errorDecrypting: true };
    let passcodeKey;
    while (decryptedStoragePayload.errorDecrypting) {
      const response = await this.requestChallengeResponse(Challenges.LocalPasscode);
      const passcode = response.value;
      passcodeKey = await this.application.protocolService.computeRootKey({
        password: passcode,
        keyParams: passcodeParams
      });
      decryptedStoragePayload = await this.application.protocolService
        .payloadByDecryptingPayload({
          payload: encryptedPayload,
          key: passcodeKey
        });
    }
    return {
      decryptedStoragePayload,
      key: passcodeKey,
      keyParams: passcodeParams
    };
  }

  /**
   * Helper
   * Web/desktop only
   */
  async webDesktopHelperExtractAndWrapAccountKeysFromValueStore(passcodeKey, storageValueStore) {
    const version = storageValueStore.ak
      ? ProtocolVersions.V003
      : ProtocolVersions.V002;
    const accountKey = await SNRootKey.Create({
      content: {
        masterKey: storageValueStore.mk,
        serverPassword: storageValueStore.pw,
        dataAuthenticationKey: storageValueStore.ak,
        version: version
      }
    });
    delete storageValueStore.mk;
    delete storageValueStore.pw;
    delete storageValueStore.ak;

    const accountKeyPayload = CreateMaxPayloadFromAnyObject({
      object: accountKey
    });
    let encryptedAccountKey;
    if (passcodeKey) {
      /** Encrypt account key with passcode */
      encryptedAccountKey = await this.application.protocolService
        .payloadByEncryptingPayload({
          payload: accountKeyPayload,
          key: passcodeKey,
          intent: EncryptionIntents.LocalStorageEncrypted
        });
    }
    return {
      accountKey: accountKey,
      wrappedKey: encryptedAccountKey
    };
  }

  /**
   * Helper
   * Web/desktop only
   * Encrypt storage with account key
   */
  async webDesktopHelperEncryptStorage(
    key,
    decryptedStoragePayload,
    storageValueStore
  ) {
    const wrapped = await this.application.protocolService.
      payloadByEncryptingPayload({
        key: key,
        intent: EncryptionIntents.LocalStoragePreferEncrypted,
        payload: CopyPayload({
          payload: decryptedStoragePayload,
          override: {
            content_type: ContentTypes.EncryptedStorage,
            content: storageValueStore,
          }
        })
      });
    return wrapped;
  }

  /**
   * Mobile
   * On mobile legacy structure is mostly similar to new structure,
   * in that the account key is encrypted with the passcode. But mobile did
   * not have encrypted storage, so we simply need to transfer all existing
   * storage values into new managed structure.
   *
   * If no account but passcode only, the only thing we stored on mobile
   * previously was keys.offline.pw and keys.offline.timing in the keychain
   * that we compared against for valid decryption.
   * In the new version, we know a passcode is correct if it can decrypt storage.
   * As part of the migration, weâ€™ll need to request the raw passcode from user,
   * compare it against the keychain offline.pw value, and if correct,
   * migrate storage to new structure, and encrypt with passcode key.
   * 
   * If account only, take the value in the keychain, and rename the values
   * (i.e mk > masterKey).
   * @access private
   */
  async migrateStorageStructureForMobile() {
    const wrappedAccountKey = await this.application.deviceInterface.getJsonParsedStorageValue(
      LEGACY_MOBILE_WRAPPED_ROOT_KEY_KEY
    );
    const rawAccountKeyParams = await this.application.deviceInterface.getJsonParsedStorageValue(
      LEGACY_ALL_ACCOUNT_KEY_PARAMS_KEY
    );
    const rawPasscodeParams = await this.application.deviceInterface.getJsonParsedStorageValue(
      LEGACY_MOBILE_PASSCODE_PARAMS_KEY
    );
    const rawStructure = {
      nonwrapped: {
        [StorageKeys.WrappedRootKey]: wrappedAccountKey,
        [StorageKeys.RootKeyWrapperKeyParams]: rawPasscodeParams,
        [StorageKeys.RootKeyParams]: rawAccountKeyParams
      },
      unwrapped: {},
    };
    const keychainValue = await this.application.deviceInterface.getKeychainValue();
    if (rawPasscodeParams) {
      const passcodeParams = this.application.protocolService
        .createKeyParams(rawPasscodeParams);
      const getPasscodeKey = async () => {
        const keychainValue = await this.application.deviceInterface.getKeychainValue();
        /** Validate current passcode by comparing against keychain offline.pw value */
        const pwHash = keychainValue.offline.pw;
        let passcodeKey = { serverPassword: null };
        while (passcodeKey.serverPassword !== pwHash) {
          const response = await this.requestChallengeResponse(Challenges.LocalPasscode);
          const passcode = response.value;
          passcodeKey = await this.application.protocolService.computeRootKey({
            password: passcode,
            keyParams: passcodeParams
          });
        }
        return passcodeKey;
      };
      const timing = keychainValue.offline.timing;
      rawStructure.unwrapped[StorageKeys.MobilePasscodeTiming] = timing;
      if (wrappedAccountKey) {
        /** 
         * Account key is encrypted with passcode. Inside, the accountKey is located inside
         * content.accountKeys. We want to unembed these values to main content, rename 
         * with proper property names, wrap again, and store in new rawStructure.
         */
        const passcodeKey = await getPasscodeKey();
        const unwrappedAccountKey = await this.application.protocolService.payloadByDecryptingPayload({
          payload: CreateMaxPayloadFromAnyObject({ object: wrappedAccountKey }),
          key: passcodeKey
        });
        const accountKeyContent = unwrappedAccountKey.content.accountKeys;
        const defaultVersion = !isNullOrUndefined(accountKeyContent.ak)
          ? ProtocolVersions.V003
          : ProtocolVersions.V002;
        const newAccountKey = CopyPayload({
          payload: unwrappedAccountKey,
          override: {
            content: {
              masterKey: accountKeyContent.mk,
              serverPassword: accountKeyContent.pw,
              dataAuthenticationKey: accountKeyContent.ak,
              version: accountKeyContent.version || defaultVersion,
              accountKeys: null
            }
          }
        });
        const newWrappedAccountKey = await this.application.protocolService.payloadByEncryptingPayload({
          payload: newAccountKey,
          key: passcodeKey,
          intent: EncryptionIntents.LocalStoragePreferEncrypted
        });
        rawStructure.nonwrapped[StorageKeys.WrappedRootKey] = newWrappedAccountKey;
      } else if (!wrappedAccountKey) {
        /** Passcode only, no account */
        const passcodeKey = await getPasscodeKey();
        const payload = CreateMaxPayloadFromAnyObject({
          object: {
            uuid: await Uuid.GenerateUuid(),
            content: rawStructure.unwrapped,
            content_type: ContentTypes.EncryptedStorage
          }
        });
        /** Encrypt new storage.unwrapped structure with passcode */
        const wrapped = await this.application.protocolService.payloadByEncryptingPayload({
          payload: payload,
          key: passcodeKey,
          intent: EncryptionIntents.LocalStoragePreferEncrypted
        });
        rawStructure.wrapped = wrapped;
      }
    } else {
      /** No passcode, potentially account. Migrate keychain property keys. */
      const hasAccount = keychainValue &amp;&amp; keychainValue.mk;
      if (hasAccount) {
        const defaultVersion = !isNullOrUndefined(keychainValue.ak)
          ? ProtocolVersions.V003
          : ProtocolVersions.V002;
        const accountKey = await SNRootKey.Create({
          content: {
            masterKey: keychainValue.mk,
            serverPassword: keychainValue.pw,
            dataAuthenticationKey: keychainValue.ak,
            version: keychainValue.version || defaultVersion
          }
        });
        await this.application.deviceInterface.setKeychainValue(
          accountKey.getPersistableValue()
        );
      }
    }

    /** Move encrypted account key into place where it is now expected */
    await this.allPlatformHelperSetStorageStructure(rawStructure);
  }

  /**
   * All platforms
   * Migrate all previously independently stored storage keys into new
   * managed approach. These keys are ones that do not need to be renamed.
   * @access private
   */
  async migrateArbitraryRawStorageToManagedStorageAllPlatforms() {
    const allKeyValues = await this.application.deviceInterface
      .getAllRawStorageKeyValues();
    const keysToExclude = [
      namespacedKey(this.application.namespace, StorageKeys.StorageObject),
      LEGACY_WEB_ENCRYPTED_STORAGE_KEY,
      LEGACY_WEB_PASSCODE_PARAMS_KEY,
      LEGACY_MOBILE_PASSCODE_PARAMS_KEY
    ];
    const tryJsonParse = (value) => {
      try { return JSON.parse(value); }
      catch (e) { return value; }
    };
    for (const keyValuePair of allKeyValues) {
      const key = keyValuePair.key;
      const value = keyValuePair.value;
      if (keysToExclude.includes(key)) {
        continue;
      }
      if (!isNullOrUndefined(value)) {
        /**
        * Raw values should always have been json stringified.
        * New values should always be objects/parsed.
        */
        const newValue = tryJsonParse(value);
        await this.application.storageService.setValue(key, newValue);
      }
    }
  }

  /**
   * All platforms
   * Create new default SNItemsKey from root key.
   * Otherwise, when data is loaded, we won't be able to decrypt it
   * without existence of an item key. This will mean that if this migration
   * is run on two different platforms for the same user, they will create
   * two new items keys. Which one they use to decrypt past items and encrypt
   * future items doesn't really matter.
   * @access private
   */
  async createDefaultItemsKeyForAllPlatforms() {
    const rootKey = await this.application.keyManager.getRootKey();
    if (rootKey) {
      const rootKeyParams = await this.application.keyManager.getRootKeyParams();
      const itemsKey = SNItemsKey.FromRaw({
        itemsKey: rootKey.masterKey,
        dataAuthenticationKey: rootKey.dataAuthenticationKey,
        version: rootKeyParams.version
      });
      await itemsKey.initUUID();
      await this.application.modelManager.mapItem({ item: itemsKey });
      await this.application.modelManager.setItemDirty(itemsKey);
    }
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Fri Feb 28 2020 14:33:50 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
