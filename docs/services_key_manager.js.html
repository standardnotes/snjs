<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>services/key_manager.js - SNJS Documentation</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountSyncOperation_AccountSyncOperation.html">AccountSyncOperation</a></li><li><a href="DeviceInterface.html">DeviceInterface</a></li><li><a href="HistorySession.html">HistorySession</a></li><li><a href="ItemsKeyManager.html">ItemsKeyManager</a><ul class='methods'><li data-type='method'><a href="ItemsKeyManager.html#addItemsKeyChangeObserver">addItemsKeyChangeObserver</a></li><li data-type='method'><a href="ItemsKeyManager.html#createNewDefaultItemsKey">createNewDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#defaultItemsKeyForItemVersion">defaultItemsKeyForItemVersion</a></li><li data-type='method'><a href="ItemsKeyManager.html#getDefaultItemsKey">getDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#handleDownloadFirstSyncCompletion">handleDownloadFirstSyncCompletion</a></li><li data-type='method'><a href="ItemsKeyManager.html#reencryptItemsKeys">reencryptItemsKeys</a></li><li data-type='method'><a href="ItemsKeyManager.html#setKeyManager">setKeyManager</a></li></ul></li><li><a href="OfflineSyncOperation_OfflineSyncOperation.html">OfflineSyncOperation</a></li><li><a href="PayloadCollectionSet_PayloadCollectionSet.html">PayloadCollectionSet</a></li><li><a href="PayloadsDelta_PayloadsDelta.html">PayloadsDelta</a></li><li><a href="SFItem.html">SFItem</a><ul class='methods'><li data-type='method'><a href="SFItem.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SFItem.html#initUUID">initUUID</a></li><li data-type='method'><a href="SFItem.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SFItem.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SFItem.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SFItem.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNActionsService.html">SNActionsService</a><ul class='methods'><li data-type='method'><a href="SNActionsService.html#loadExtensionInContextOfItem">loadExtensionInContextOfItem</a></li></ul></li><li><a href="SNAlertService.html">SNAlertService</a></li><li><a href="SNApplication.html">SNApplication</a><ul class='methods'><li data-type='method'><a href="SNApplication.html#addEventObserver">addEventObserver</a></li><li data-type='method'><a href="SNApplication.html#addSingleEventObserver">addSingleEventObserver</a></li><li data-type='method'><a href="SNApplication.html#changeDeviceInterface">changeDeviceInterface</a></li><li data-type='method'><a href="SNApplication.html#changePasscode">changePasscode</a></li><li data-type='method'><a href="SNApplication.html#changePassword">changePassword</a></li><li data-type='method'><a href="SNApplication.html#clearDatabase">clearDatabase</a></li><li data-type='method'><a href="SNApplication.html#createItem">createItem</a></li><li data-type='method'><a href="SNApplication.html#deinit">deinit</a></li><li data-type='method'><a href="SNApplication.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="SNApplication.html#deleteItemLocally">deleteItemLocally</a></li><li data-type='method'><a href="SNApplication.html#emptyTrash">emptyTrash</a></li><li data-type='method'><a href="SNApplication.html#findItem">findItem</a></li><li data-type='method'><a href="SNApplication.html#findItems">findItems</a></li><li data-type='method'><a href="SNApplication.html#findOrCreateTag">findOrCreateTag</a></li><li data-type='method'><a href="SNApplication.html#findTag">findTag</a></li><li data-type='method'><a href="SNApplication.html#generateUuid">generateUuid</a></li><li data-type='method'><a href="SNApplication.html#getDisplayableItems">getDisplayableItems</a></li><li data-type='method'><a href="SNApplication.html#getHost">getHost</a></li><li data-type='method'><a href="SNApplication.html#getItems">getItems</a></li><li data-type='method'><a href="SNApplication.html#getNoteCount">getNoteCount</a></li><li data-type='method'><a href="SNApplication.html#getNotesMatchingSmartTag">getNotesMatchingSmartTag</a></li><li data-type='method'><a href="SNApplication.html#getSmartTags">getSmartTags</a></li><li data-type='method'><a href="SNApplication.html#getSyncStatus">getSyncStatus</a></li><li data-type='method'><a href="SNApplication.html#getTrashedItems">getTrashedItems</a></li><li data-type='method'><a href="SNApplication.html#getUser">getUser</a></li><li data-type='method'><a href="SNApplication.html#getUserVersion">getUserVersion</a></li><li data-type='method'><a href="SNApplication.html#getValue">getValue</a></li><li data-type='method'><a href="SNApplication.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNApplication.html#importData">importData</a></li><li data-type='method'><a href="SNApplication.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNApplication.html#isEphemeralSession">isEphemeralSession</a></li><li data-type='method'><a href="SNApplication.html#isLocked">isLocked</a></li><li data-type='method'><a href="SNApplication.html#isStarted">isStarted</a></li><li data-type='method'><a href="SNApplication.html#launch">launch</a></li><li data-type='method'><a href="SNApplication.html#lock">lock</a></li><li data-type='method'><a href="SNApplication.html#mergeItem">mergeItem</a></li><li data-type='method'><a href="SNApplication.html#noAccount">noAccount</a></li><li data-type='method'><a href="SNApplication.html#prepareForLaunch">prepareForLaunch</a></li><li data-type='method'><a href="SNApplication.html#register">register</a></li><li data-type='method'><a href="SNApplication.html#registerService">registerService</a></li><li data-type='method'><a href="SNApplication.html#removePasscode">removePasscode</a></li><li data-type='method'><a href="SNApplication.html#removeValue">removeValue</a></li><li data-type='method'><a href="SNApplication.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNApplication.html#restart">restart</a></li><li data-type='method'><a href="SNApplication.html#saveItem">saveItem</a></li><li data-type='method'><a href="SNApplication.html#saveItems">saveItems</a></li><li data-type='method'><a href="SNApplication.html#savePayload">savePayload</a></li><li data-type='method'><a href="SNApplication.html#setHost">setHost</a></li><li data-type='method'><a href="SNApplication.html#setItemNeedsSync">setItemNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setItemsNeedsSync">setItemsNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setPasscode">setPasscode</a></li><li data-type='method'><a href="SNApplication.html#setStorageEncryptionPolicy">setStorageEncryptionPolicy</a></li><li data-type='method'><a href="SNApplication.html#setValue">setValue</a></li><li data-type='method'><a href="SNApplication.html#signIn">signIn</a></li><li data-type='method'><a href="SNApplication.html#signOut">signOut</a></li><li data-type='method'><a href="SNApplication.html#streamItems">streamItems</a></li><li data-type='method'><a href="SNApplication.html#sync">sync</a></li><li data-type='method'><a href="SNApplication.html#validateAccountPassword">validateAccountPassword</a></li></ul></li><li><a href="SNComponentManager.html">SNComponentManager</a><ul class='methods'><li data-type='method'><a href="SNComponentManager.html#deinit">deinit</a></li></ul></li><li><a href="SNEditor.html">SNEditor</a></li><li><a href="SNHistoryManager.html">SNHistoryManager</a></li><li><a href="SNHttpService.html">SNHttpService</a></li><li><a href="SNKeyManager.html">SNKeyManager</a><ul class='methods'><li data-type='method'><a href="SNKeyManager.html#clearLocalKeyState">clearLocalKeyState</a></li><li data-type='method'><a href="SNKeyManager.html#contentTypeUsesRootKeyEncryption">contentTypeUsesRootKeyEncryption</a></li><li data-type='method'><a href="SNKeyManager.html#getAccountKeyParams">getAccountKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKey">getRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyParams">getRootKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyWrapperKeyParams">getRootKeyWrapperKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNKeyManager.html#hasRootKeyWrapper">hasRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForDecryptionOfPayload">keyToUseForDecryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForEncryptionOfPayload">keyToUseForEncryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="SNKeyManager.html#removeRootKeyWrapper">removeRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#rootKeyNeedsUnwrapping">rootKeyNeedsUnwrapping</a></li><li data-type='method'><a href="SNKeyManager.html#setDeviceInterface">setDeviceInterface</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKey">setNewRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKeyWrapper">setNewRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#unwrapRootKey">unwrapRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#validateAccountPassword">validateAccountPassword</a></li><li data-type='method'><a href="SNKeyManager.html#validatePasscode">validatePasscode</a></li><li data-type='method'><a href="SNKeyManager.html#validateWrappingKey">validateWrappingKey</a></li></ul></li><li><a href="SNMaxItemPayload.html">SNMaxItemPayload</a></li><li><a href="SNModelManager.html">SNModelManager</a><ul class='methods'><li data-type='method'><a href="SNModelManager.html#addItem">addItem</a></li><li data-type='method'><a href="SNModelManager.html#createItem">createItem</a></li><li data-type='method'><a href="SNModelManager.html#getMasterCollection">getMasterCollection</a></li><li data-type='method'><a href="SNModelManager.html#insertItem">insertItem</a></li><li data-type='method'><a href="SNModelManager.html#insertItems">insertItems</a></li><li data-type='method'><a href="SNModelManager.html#setItemDirty">setItemDirty</a></li><li data-type='method'><a href="SNModelManager.html#setItemProperties">setItemProperties</a></li></ul></li><li><a href="SNNote.html">SNNote</a><ul class='methods'><li data-type='method'><a href="SNNote.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SNNote.html#initUUID">initUUID</a></li><li data-type='method'><a href="SNNote.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SNNote.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SNNote.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SNNote.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNNoteSFItem.html">SFItem</a></li><li><a href="SNNoteSNNoteSFItem.html">SFItem</a></li><li><a href="SNPrivilegesService.html">SNPrivilegesService</a><ul class='methods'><li data-type='method'><a href="SNPrivilegesService.html#actionRequiresPrivilege">actionRequiresPrivilege</a></li><li data-type='method'><a href="SNPrivilegesService.html#netCredentialsForAction">netCredentialsForAction</a></li></ul></li><li><a href="SNProtocolService.html">SNProtocolService</a><ul class='methods'><li data-type='method'><a href="SNProtocolService.html#compareRootKeys">compareRootKeys</a></li><li data-type='method'><a href="SNProtocolService.html#createBackupFile">createBackupFile</a></li><li data-type='method'><a href="SNProtocolService.html#decryptErroredItems">decryptErroredItems</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByDecryptingPayload">payloadByDecryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByEncryptingPayload">payloadByEncryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#setKeyManager">setKeyManager</a></li><li data-type='method'><a href="SNProtocolService.html#supportedVersions">supportedVersions</a></li></ul></li><li><a href="SNSavedServerItemPayload.html">SNSavedServerItemPayload</a></li><li><a href="SNSessionManager.html">SNSessionManager</a></li><li><a href="SNSingletonManager.html">SNSingletonManager</a><ul class='methods'><li data-type='method'><a href="SNSingletonManager.html#addObservers">addObservers</a></li><li data-type='method'><a href="SNSingletonManager.html#registerPredicate">registerPredicate</a></li></ul></li><li><a href="SNStorageService.html">SNStorageService</a><ul class='methods'><li data-type='method'><a href="SNStorageService.html#canDecryptWithKey">canDecryptWithKey</a></li><li data-type='method'><a href="SNStorageService.html#clearValues">clearValues</a></li><li data-type='method'><a href="SNStorageService.html#decryptStorage">decryptStorage</a></li><li data-type='method'><a href="SNStorageService.html#generatePersistenceValue">generatePersistenceValue</a></li><li data-type='method'><a href="SNStorageService.html#getAllRawPayloads">getAllRawPayloads</a></li><li data-type='method'><a href="SNStorageService.html#getPersistenceKey">getPersistenceKey</a></li><li data-type='method'><a href="SNStorageService.html#handleApplicationStage">handleApplicationStage</a></li><li data-type='method'><a href="SNStorageService.html#isStorageWrapped">isStorageWrapped</a></li><li data-type='method'><a href="SNStorageService.html#setInitialValues">setInitialValues</a></li></ul></li><li><a href="SNSyncService.html">SNSyncService</a><ul class='methods'><li data-type='method'><a href="SNSyncService.html#computeDataIntegrityHash">computeDataIntegrityHash</a></li><li data-type='method'><a href="SNSyncService.html#getDatabasePayloads">getDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#handleNeverSyncedDeleted">handleNeverSyncedDeleted</a></li><li data-type='method'><a href="SNSyncService.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNSyncService.html#loadDatabasePayloads">loadDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#markAllItemsAsNeedingSync">markAllItemsAsNeedingSync</a></li><li data-type='method'><a href="SNSyncService.html#payloadsByPreparingForServer">payloadsByPreparingForServer</a></li><li data-type='method'><a href="SNSyncService.html#popPayloadsNeedingPreSyncSave">popPayloadsNeedingPreSyncSave</a></li><li data-type='method'><a href="SNSyncService.html#popSpawnQueue">popSpawnQueue</a></li><li data-type='method'><a href="SNSyncService.html#repersistAllItems">repersistAllItems</a></li><li data-type='method'><a href="SNSyncService.html#resetSyncState">resetSyncState</a></li><li data-type='method'><a href="SNSyncService.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNSyncService.html#sync">sync</a></li><li data-type='method'><a href="SNSyncService.html#ut_beginLatencySimulator">ut_beginLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_endLatencySimulator">ut_endLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_setDatabaseLoaded">ut_setDatabaseLoaded</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayByDifference">arrayByDifference</a></li><li><a href="global.html#arrayByRemovingFromIndex">arrayByRemovingFromIndex</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#deepMerge">deepMerge</a></li><li><a href="global.html#DEFAULT_AUTO_SYNC_INTERVAL">DEFAULT_AUTO_SYNC_INTERVAL</a></li><li><a href="global.html#DEFAULT_ITEM_REVISIONS_THRESHOLD">DEFAULT_ITEM_REVISIONS_THRESHOLD</a></li><li><a href="global.html#extendArray">extendArray</a></li><li><a href="global.html#intentRequiresEncryption">intentRequiresEncryption</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_NONE">KEY_MODE_ROOT_KEY_NONE</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_ONLY">KEY_MODE_ROOT_KEY_ONLY</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_PLUS_WRAPPER">KEY_MODE_ROOT_KEY_PLUS_WRAPPER</a></li><li><a href="global.html#KEY_MODE_WRAPPER_ONLY">KEY_MODE_WRAPPER_ONLY</a></li><li><a href="global.html#LARGE_ENTRY_DELTA_THRESHOLD">LARGE_ENTRY_DELTA_THRESHOLD</a></li><li><a href="global.html#LAST_NONROOT_ITEMS_KEY_VERSION">LAST_NONROOT_ITEMS_KEY_VERSION</a></li><li><a href="global.html#lastElement">lastElement</a></li><li><a href="global.html#omitByCopy">omitByCopy</a></li><li><a href="global.html#PayloadsByAlternatingUuid">PayloadsByAlternatingUuid</a></li><li><a href="global.html#PayloadsByDuplicating">PayloadsByDuplicating</a></li><li><a href="global.html#pickByCopy">pickByCopy</a></li><li><a href="global.html#RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP">RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#removeFromIndex">removeFromIndex</a></li><li><a href="global.html#SortPayloadsByRecentAndContentPriority">SortPayloadsByRecentAndContentPriority</a></li><li><a href="global.html#StorageEncryptionPolicies">StorageEncryptionPolicies</a></li><li><a href="global.html#StoragePersistencePolicies">StoragePersistencePolicies</a></li><li><a href="global.html#StorageValueModes">StorageValueModes</a></li><li><a href="global.html#subtractFromArray">subtractFromArray</a></li><li><a href="global.html#ValueModesKeys">ValueModesKeys</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">services/key_manager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { PureService } from '@Lib/services/pure_service';
import { isNullOrUndefined, removeFromArray } from '@Lib/utils';
import { CreateMaxPayloadFromAnyObject } from '@Payloads';
import { ContentTypes } from '@Models/content_types';
import { StorageKeys } from '@Lib/storage_keys';
import { SNRootKey, EncryptionIntents, intentRequiresEncryption } from '@Protocol';
import { StorageValueModes } from '@Lib/services/storage_service';

/** i.e No account and no passcode */
export const KEY_MODE_ROOT_KEY_NONE = 0;
/** i.e Account but no passcode */
export const KEY_MODE_ROOT_KEY_ONLY = 1;
/** i.e Account plus passcode */
export const KEY_MODE_ROOT_KEY_PLUS_WRAPPER = 2;
/** i.e No account, but passcode */
export const KEY_MODE_WRAPPER_ONLY = 3;

/** 
 * The key manager is responsible for managing root key and root key wrapper states.
 * When the key manager is initialized, it initiates itself with a keyMode, which 
 * dictates the entire flow of key management. The key manager's responsibilities include:
 * - interacting with the device keychain to save or clear the root key
 * - interacting with storage to save root key params or wrapper params, or the wrapped root key.
 * - exposing methods that allow the application to unwrap the root key (unlock the application)
 * 
 * It also exposes two primary methods for determing what key should be used to encrypt
 * or decrypt a particular payload. Some payloads are encrypted directly with the rootKey
 * (such as itemsKeys and encryptedStorage). Others are encrypted with itemsKeys (notes, tags, etc).
 */
export class SNKeyManager extends PureService {
  constructor({ modelManager, storageService, protocolService, itemsKeyManager }) {
    if (!modelManager || !storageService || !protocolService || !itemsKeyManager) {
      throw 'Invalid KeyManager construction';
    }
    super();
    this.keyMode = KEY_MODE_ROOT_KEY_NONE;
    this.protocolService = protocolService;
    this.modelManager = modelManager;
    this.storageService = storageService;
    this.itemsKeyManager = itemsKeyManager;
    this.keyObservers = [];

    /** Hide rootKey enumeration */
    Object.defineProperty(this, 'rootKey', {
      enumerable: false,
      writable: true
    });
  }

  async initialize() {
    const wrappedRootKey = await this.getWrappedRootKeyFromStorage();
    const accountKeyParams = await this.getAccountKeyParams();
    const hasWrapper = await this.hasRootKeyWrapper();
    const hasRootKey =
      !isNullOrUndefined(wrappedRootKey) ||
      !isNullOrUndefined(accountKeyParams);
    if (hasWrapper &amp;&amp; hasRootKey) {
      this.keyMode = KEY_MODE_ROOT_KEY_PLUS_WRAPPER;
    } else if (hasWrapper &amp;&amp; !hasRootKey) {
      this.keyMode = KEY_MODE_WRAPPER_ONLY;
    } else if (!hasWrapper &amp;&amp; hasRootKey) {
      this.keyMode = KEY_MODE_ROOT_KEY_ONLY;
    } else if (!hasWrapper &amp;&amp; !hasRootKey) {
      this.keyMode = KEY_MODE_ROOT_KEY_NONE;
    } else {
      throw 'Invalid key mode condition';
    }

    if (this.keyMode === KEY_MODE_ROOT_KEY_ONLY) {
      this.rootKey = await this.getRootKeyFromKeychain();
      await this.notifyObserversOfChange();
    }
  }

  /**
   * @param callback  A function that takes in a content type to call back when root
   *                  key or wrapper status has changed.
   */
  onStatusChange(callback) {
    this.keyObservers.push(callback);
    return () => {
      removeFromArray(this.keyObservers, callback);
    };
  }

  async notifyObserversOfChange() {
    for (const observer of this.keyObservers) {
      await observer();
    }
  }

  /**
   * Dynamically set a DeviceInterface object
   */
  setDeviceInterface(deviceInterface) {
    this.deviceInterface = deviceInterface;
  }

  /** @access private */
  async getRootKeyFromKeychain() {
    const rawKey = await this.deviceInterface.getKeychainValue();
    if (isNullOrUndefined(rawKey)) {
      return null;
    }
    const rootKey = await SNRootKey.Create({
      content: rawKey
    });
    return rootKey;
  }

  /** @access private */
  async saveRootKeyToKeychain() {
    if (isNullOrUndefined(this.rootKey)) {
      throw 'Attempting to non-existent root key to the keychain.';
    }
    if (this.keyMode !== KEY_MODE_ROOT_KEY_ONLY) {
      throw 'Should not be persisting wrapped key to keychain.';
    }
    const rawKey = this.rootKey.getPersistableValue();
    await this.deviceInterface.setKeychainValue(rawKey);
  }

  /**
   * @access public
   * Returns true if a root key wrapper (passcode) is configured.
   */
  async hasRootKeyWrapper() {
    const wrapper = await this.getRootKeyWrapperKeyParams();
    return !isNullOrUndefined(wrapper);
  }

  /**
   * @access public
   * A non-async alternative to `hasRootKeyWrapper` which uses pre-loaded state
   * to determine if a passcode is configured.
   */
  hasPasscode() {
    return (
      this.keyMode === KEY_MODE_WRAPPER_ONLY ||
      this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    );
  }

  /**
   * @access public
   * Returns true if the root key has not yet been unwrapped (passcode locked).
   */
  async rootKeyNeedsUnwrapping() {
    return await this.hasRootKeyWrapper() &amp;&amp; isNullOrUndefined(this.rootKey);
  }

  /**
   * @access public
   * @returns  Key params object containing root key wrapper key params
   */
  async getRootKeyWrapperKeyParams() {
    const rawKeyParams = await this.storageService.getValue(
      StorageKeys.RootKeyWrapperKeyParams,
      StorageValueModes.Nonwrapped
    );
    if (!rawKeyParams) {
      return null;
    }
    return this.protocolService.createKeyParams(rawKeyParams);
  }

  /**
   * @access private
   * @returns  Plain object containing persisted wrapped (encrypted) root key
   */
  async getWrappedRootKeyFromStorage() {
    return this.storageService.getValue(
      StorageKeys.WrappedRootKey,
      StorageValueModes.Nonwrapped
    );
  }

  /**
   * @access public
   * @returns  The keyParams saved to disk for root key.
   */
  async getRootKeyParams() {
    if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
      return this.getRootKeyWrapperKeyParams();
    } else if ((
      this.keyMode === KEY_MODE_ROOT_KEY_ONLY ||
      this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    )) {
      return this.getAccountKeyParams();
    } else {
      throw `Unhandled key mode for getRootKeyParams ${this.keyMode}`;
    }
  }

  /**
   * @access public
   * @returns  getRootKeyParams may return different params based on different
   *           keyMode. This function however strictly returns only account params.
   */
  async getAccountKeyParams() {
    const rawKeyParams = await this.storageService.getValue(
      StorageKeys.RootKeyParams,
      StorageValueModes.Nonwrapped
    );
    if (!rawKeyParams) {
      return null;
    }
    return this.protocolService.createKeyParams(rawKeyParams);
  }

  /**
   * @access public
   * We know a wrappingKey is correct if it correctly decrypts
   * wrapped root key.
   */
  async validateWrappingKey(wrappingKey) {
    const wrappedRootKey = await this.getWrappedRootKeyFromStorage();
    /** If wrapper only, storage is encrypted directly with wrappingKey */
    if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
      return this.storageService.canDecryptWithKey(wrappingKey);
    } else if ((
      this.keyMode === KEY_MODE_ROOT_KEY_ONLY ||
      this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    )) {
      /**
      * In these modes, storage is encrypted with account keys, and
      * account keys are encrypted with wrappingKey. Here we validate
      * by attempting to decrypt account keys.
      */
      const wrappedKeyPayload = CreateMaxPayloadFromAnyObject({
        object: wrappedRootKey
      });
      const decrypted = await this.protocolService.payloadByDecryptingPayload({
        payload: wrappedKeyPayload,
        key: wrappingKey
      });
      return !decrypted.errorDecrypting;
    } else {
      throw 'Unhandled case in validateWrappingKey';
    }
  }

  async computeWrappingKey({ passcode }) {
    const keyParams = await this.getRootKeyWrapperKeyParams();
    const key = await this.protocolService.computeRootKey({
      password: passcode,
      keyParams: keyParams
    });
    return key;
  }

  /**
   * @access public
   * Application interfaces must check to see if the root key requires unwrapping on load.
   * If so, they must generate the unwrapping key by getting our saved wrapping key keyParams.
   * After unwrapping, the root key is automatically loaded.
  */
  async unwrapRootKey({ wrappingKey }) {
    if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
      this.rootKey = wrappingKey;
      return;
    }
    if (this.keyMode !== KEY_MODE_ROOT_KEY_PLUS_WRAPPER) {
      throw 'Invalid key mode condition for unwrapping.';
    }
    const wrappedKey = await this.getWrappedRootKeyFromStorage();
    const payload = CreateMaxPayloadFromAnyObject({ object: wrappedKey });
    const decrypted = await this.protocolService.payloadByDecryptingPayload({
      payload: payload,
      key: wrappingKey
    });
    if (decrypted.errorDecrypting) {
      throw 'Unable to decrypt root key with provided wrapping key.';
    } else {
      this.rootKey = await SNRootKey.Create({
        uuid: decrypted.uuid,
        content: decrypted.content
      });
      await this.notifyObserversOfChange();
    }
  }

  /**
   * @access public
   * Encrypts rootKey and saves it in storage instead of keychain, and then
   * clears keychain. This is because we don't want to store large encrypted
   * payloads in the keychain. If the root key is not wrapped, it is stored
   * in plain form in the user's secure keychain.
  */
  async setNewRootKeyWrapper({ wrappingKey, keyParams }) {
    if (this.keyMode === KEY_MODE_ROOT_KEY_NONE) {
      this.keyMode = KEY_MODE_WRAPPER_ONLY;
    } else if (this.keyMode === KEY_MODE_ROOT_KEY_ONLY) {
      this.keyMode = KEY_MODE_ROOT_KEY_PLUS_WRAPPER;
    } else {
      throw 'Attempting to set wrapper on already wrapped key.';
    }

    await this.deviceInterface.clearKeychainValue();

    if ((
      this.keyMode === KEY_MODE_WRAPPER_ONLY ||
      this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    )) {
      if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
        this.rootKey = wrappingKey;
        await this.itemsKeyManager.reencryptItemsKeys();
      } else {
        await this.persistWrappedRootKey({
          wrappingKey: wrappingKey
        });
      }

      await this.storageService.setValue(
        StorageKeys.RootKeyWrapperKeyParams,
        keyParams.getPortableValue(),
        StorageValueModes.Nonwrapped
      );
      await this.notifyObserversOfChange();
      return;
    }

    throw 'Invalid keyMode on setNewRootKeyWrapper';
  }

  /** @access private */
  async persistWrappedRootKey({ wrappingKey }) {
    const payload = CreateMaxPayloadFromAnyObject({
      object: this.rootKey,
      override: {
        content: this.rootKey.getPersistableValue()
      }
    });
    const wrappedKey = await this.protocolService.payloadByEncryptingPayload({
      payload: payload,
      key: wrappingKey,
      intent: EncryptionIntents.LocalStorageEncrypted
    });
    await this.storageService.setValue(
      StorageKeys.WrappedRootKey,
      wrappedKey,
      StorageValueModes.Nonwrapped
    );
  }

  /**
   * @access public
   * Removes root key wrapper from local storage and stores root keys bare in secure keychain.
   */
  async removeRootKeyWrapper() {
    if ((
      this.keyMode !== KEY_MODE_WRAPPER_ONLY &amp;&amp;
      this.keyMode !== KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    )) {
      throw 'Attempting to remove root key wrapper on unwrapped key.';
    }

    if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
      this.keyMode = KEY_MODE_ROOT_KEY_NONE;
      this.rootKey = null;
    } else if (this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER) {
      this.keyMode = KEY_MODE_ROOT_KEY_ONLY;
    }

    await this.storageService.removeValue(
      StorageKeys.WrappedRootKey,
      StorageValueModes.Nonwrapped
    );
    await this.storageService.removeValue(
      StorageKeys.RootKeyWrapperKeyParams,
      StorageValueModes.Nonwrapped
    );

    if (this.keyMode === KEY_MODE_ROOT_KEY_ONLY) {
      await this.saveRootKeyToKeychain();
    }
    await this.notifyObserversOfChange();
  }

  /**
   * @access public
   * The root key is distinct from regular keys and are only saved locally in the keychain,
   * in non-item form. Applications set root key on sign in, register, or password change.
   * @param key  A SNRootKey object.
   */
  async setNewRootKey({ key, keyParams }) {
    if (!key.isRootKey) {
      throw `Root key must be a ${ContentTypes.RootKey} object.`;
    }
    if (!keyParams) {
      throw 'keyParams must be supplied if setting root key.';
    }

    if (this.keyMode === KEY_MODE_WRAPPER_ONLY) {
      this.keyMode = KEY_MODE_ROOT_KEY_PLUS_WRAPPER;
    } else if (this.keyMode === KEY_MODE_ROOT_KEY_NONE) {
      this.keyMode = KEY_MODE_ROOT_KEY_ONLY;
    } else if ((
      this.keyMode === KEY_MODE_ROOT_KEY_ONLY ||
      this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER
    )) {
      /** Root key is simply changing, mode stays the same */
      /** this.keyMode = this.keyMode; */
    } else {
      throw `Unhandled key mode for setNewRootKey ${this.keyMode}`;
    }

    const previousRootKey = this.rootKey;
    this.rootKey = key;

    if (previousRootKey === key) {
      throw 'Attempting to set root key as same current value.';
    }

    await this.storageService.setValue(
      StorageKeys.RootKeyParams,
      keyParams.getPortableValue(),
      StorageValueModes.Nonwrapped
    );
    if (this.keyMode === KEY_MODE_ROOT_KEY_ONLY) {
      await this.saveRootKeyToKeychain();
    } else if (this.keyMode === KEY_MODE_ROOT_KEY_PLUS_WRAPPER) {
      await this.persistWrappedRootKey({ wrappingKey: previousRootKey });
    }

    await this.notifyObserversOfChange(ContentTypes.RootKey);
    await this.itemsKeyManager.reencryptItemsKeys();
  }

  /**
   * @access public
   * @returns  SNRootKey object
   */
  async getRootKey() {
    return this.rootKey;
  }

  /**
   * @access public
   * Deletes root key and wrapper from keychain. Used when signing out of application.
   */
  async clearLocalKeyState() {
    await this.deviceInterface.clearKeychainValue();
    await this.storageService.removeValue(
      StorageKeys.WrappedRootKey,
      StorageValueModes.Nonwrapped
    );
    await this.storageService.removeValue(
      StorageKeys.RootKeyWrapperKeyParams,
      StorageValueModes.Nonwrapped
    );
    await this.storageService.removeValue(
      StorageKeys.RootKeyParams,
      StorageValueModes.Nonwrapped
    );
    this.keyMode = KEY_MODE_ROOT_KEY_NONE;
    this.rootKey = null;
    await this.notifyObserversOfChange();
  }

  /**
   * @param password {string}: The password string to generate a root key from.
   * @returns key|null: Key if valid password, otherwise null.
   */
  async validateAccountPassword(password) {
    const keyParams = await this.getRootKeyParams();
    const key = await this.protocolService.computeRootKey({ password, keyParams });
    const success = await this.protocolService.compareRootKeys(key, this.rootKey);
    return success ? key : null;
  }

  /**
   * @param passcode {string}: The passcode string to generate a root key from.
   * @returns {boolean}: Whether the input passcode generates wrapping keys equal
   * to the ones saved.
   */
  async validatePasscode(passcode) {
    const keyParams = await this.getRootKeyWrapperKeyParams();
    const key = await this.protocolService.computeRootKey({ 
      password: passcode, 
      keyParams: keyParams 
    });
    return this.validateWrappingKey(key);
  }

  /**
   * Only two types of items should be encrypted with a root key:
   * - An SNItemsKey object
   * - An encrypted storage object (local)
   */
  contentTypeUsesRootKeyEncryption(contentType) {
    return (
      contentType === ContentTypes.ItemsKey ||
      contentType === ContentTypes.EncryptedStorage
    );
  }

  /**
   * @returns  The SNItemsKey object to use for encrypting this item.
               For regular items, should be equal too this.getDefaultItemsKey.
               For SNItemsKey items, should be equal to root keys.
  */
  async keyToUseForEncryptionOfPayload({ payload, intent }) {
    if (isNullOrUndefined(intent)) {
      throw 'Intent must be supplied when looking up key for encryption of item.';
    }
    if (this.contentTypeUsesRootKeyEncryption(payload.content_type)) {
      const rootKey = await this.getRootKey();
      if (!rootKey) {
        if (intentRequiresEncryption(intent)) {
          throw 'Root key encryption is required but no root key is available.';
        } else {
          return null;
        }
      }
      return rootKey;
    } else {
      return this.itemsKeyManager.getDefaultItemsKey();
    }
  }

  /**
   * Payloads could have been previously encrypted with any arbitrary SNItemsKey object.
   * If the payload is an items key object, it is always encrypted with the root key,
   * and so return that. Otherwise, we check to see if the payload has an
   * items_key_id and return that key. If it doesn't, this means the payload was
   * encrypted with legacy behavior. We return then the key object corresponding
   * to the version of this payload.
   * @returns  The SNItemsKey object to use for decrypting this payload.
  */
  async keyToUseForDecryptionOfPayload({ payload }) {
    if (this.contentTypeUsesRootKeyEncryption(payload.content_type)) {
      return this.getRootKey();
    }
    if (payload.items_key_id) {
      const itemsKey = this.itemsKeyManager.itemsKeyForPayload(payload);
      return itemsKey;
    }
    const payloadVersion = this.protocolService.versionForPayload(payload);
    if (payloadVersion === this.protocolService.getLatestVersion()) {
      throw 'No associated key found for item encrypted with latest protocol version.';
    }
    return this.itemsKeyManager.defaultItemsKeyForItemVersion(payloadVersion);
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Thu Feb 27 2020 12:31:59 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
