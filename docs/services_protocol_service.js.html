<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>services/protocol_service.js - SNJS Documentation</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountSyncOperation_AccountSyncOperation.html">AccountSyncOperation</a></li><li><a href="DeviceInterface.html">DeviceInterface</a></li><li><a href="HistorySession.html">HistorySession</a></li><li><a href="ItemsKeyManager.html">ItemsKeyManager</a><ul class='methods'><li data-type='method'><a href="ItemsKeyManager.html#addItemsKeyChangeObserver">addItemsKeyChangeObserver</a></li><li data-type='method'><a href="ItemsKeyManager.html#createNewDefaultItemsKey">createNewDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#defaultItemsKeyForItemVersion">defaultItemsKeyForItemVersion</a></li><li data-type='method'><a href="ItemsKeyManager.html#getDefaultItemsKey">getDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#handleDownloadFirstSyncCompletion">handleDownloadFirstSyncCompletion</a></li><li data-type='method'><a href="ItemsKeyManager.html#reencryptItemsKeys">reencryptItemsKeys</a></li><li data-type='method'><a href="ItemsKeyManager.html#setKeyManager">setKeyManager</a></li></ul></li><li><a href="OfflineSyncOperation_OfflineSyncOperation.html">OfflineSyncOperation</a></li><li><a href="PayloadCollectionSet_PayloadCollectionSet.html">PayloadCollectionSet</a></li><li><a href="PayloadsDelta_PayloadsDelta.html">PayloadsDelta</a></li><li><a href="SFItem.html">SFItem</a><ul class='methods'><li data-type='method'><a href="SFItem.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SFItem.html#initUUID">initUUID</a></li><li data-type='method'><a href="SFItem.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SFItem.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SFItem.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SFItem.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNActionsService.html">SNActionsService</a><ul class='methods'><li data-type='method'><a href="SNActionsService.html#loadExtensionInContextOfItem">loadExtensionInContextOfItem</a></li></ul></li><li><a href="SNAlertService.html">SNAlertService</a></li><li><a href="SNApplication.html">SNApplication</a><ul class='methods'><li data-type='method'><a href="SNApplication.html#addEventObserver">addEventObserver</a></li><li data-type='method'><a href="SNApplication.html#addSingleEventObserver">addSingleEventObserver</a></li><li data-type='method'><a href="SNApplication.html#changeDeviceInterface">changeDeviceInterface</a></li><li data-type='method'><a href="SNApplication.html#changePasscode">changePasscode</a></li><li data-type='method'><a href="SNApplication.html#changePassword">changePassword</a></li><li data-type='method'><a href="SNApplication.html#clearDatabase">clearDatabase</a></li><li data-type='method'><a href="SNApplication.html#createItem">createItem</a></li><li data-type='method'><a href="SNApplication.html#deinit">deinit</a></li><li data-type='method'><a href="SNApplication.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="SNApplication.html#deleteItemLocally">deleteItemLocally</a></li><li data-type='method'><a href="SNApplication.html#emptyTrash">emptyTrash</a></li><li data-type='method'><a href="SNApplication.html#findItem">findItem</a></li><li data-type='method'><a href="SNApplication.html#findItems">findItems</a></li><li data-type='method'><a href="SNApplication.html#findOrCreateTag">findOrCreateTag</a></li><li data-type='method'><a href="SNApplication.html#findTag">findTag</a></li><li data-type='method'><a href="SNApplication.html#generateUuid">generateUuid</a></li><li data-type='method'><a href="SNApplication.html#getDisplayableItems">getDisplayableItems</a></li><li data-type='method'><a href="SNApplication.html#getHost">getHost</a></li><li data-type='method'><a href="SNApplication.html#getItems">getItems</a></li><li data-type='method'><a href="SNApplication.html#getNoteCount">getNoteCount</a></li><li data-type='method'><a href="SNApplication.html#getNotesMatchingSmartTag">getNotesMatchingSmartTag</a></li><li data-type='method'><a href="SNApplication.html#getSmartTags">getSmartTags</a></li><li data-type='method'><a href="SNApplication.html#getSyncStatus">getSyncStatus</a></li><li data-type='method'><a href="SNApplication.html#getTrashedItems">getTrashedItems</a></li><li data-type='method'><a href="SNApplication.html#getUser">getUser</a></li><li data-type='method'><a href="SNApplication.html#getUserVersion">getUserVersion</a></li><li data-type='method'><a href="SNApplication.html#getValue">getValue</a></li><li data-type='method'><a href="SNApplication.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNApplication.html#importData">importData</a></li><li data-type='method'><a href="SNApplication.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNApplication.html#isEphemeralSession">isEphemeralSession</a></li><li data-type='method'><a href="SNApplication.html#isLocked">isLocked</a></li><li data-type='method'><a href="SNApplication.html#isStarted">isStarted</a></li><li data-type='method'><a href="SNApplication.html#launch">launch</a></li><li data-type='method'><a href="SNApplication.html#lock">lock</a></li><li data-type='method'><a href="SNApplication.html#mergeItem">mergeItem</a></li><li data-type='method'><a href="SNApplication.html#noAccount">noAccount</a></li><li data-type='method'><a href="SNApplication.html#prepareForLaunch">prepareForLaunch</a></li><li data-type='method'><a href="SNApplication.html#register">register</a></li><li data-type='method'><a href="SNApplication.html#registerService">registerService</a></li><li data-type='method'><a href="SNApplication.html#removePasscode">removePasscode</a></li><li data-type='method'><a href="SNApplication.html#removeValue">removeValue</a></li><li data-type='method'><a href="SNApplication.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNApplication.html#restart">restart</a></li><li data-type='method'><a href="SNApplication.html#saveItem">saveItem</a></li><li data-type='method'><a href="SNApplication.html#saveItems">saveItems</a></li><li data-type='method'><a href="SNApplication.html#savePayload">savePayload</a></li><li data-type='method'><a href="SNApplication.html#setHost">setHost</a></li><li data-type='method'><a href="SNApplication.html#setItemNeedsSync">setItemNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setItemsNeedsSync">setItemsNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setPasscode">setPasscode</a></li><li data-type='method'><a href="SNApplication.html#setStorageEncryptionPolicy">setStorageEncryptionPolicy</a></li><li data-type='method'><a href="SNApplication.html#setValue">setValue</a></li><li data-type='method'><a href="SNApplication.html#signIn">signIn</a></li><li data-type='method'><a href="SNApplication.html#signOut">signOut</a></li><li data-type='method'><a href="SNApplication.html#streamItems">streamItems</a></li><li data-type='method'><a href="SNApplication.html#sync">sync</a></li><li data-type='method'><a href="SNApplication.html#validateAccountPassword">validateAccountPassword</a></li></ul></li><li><a href="SNComponentManager.html">SNComponentManager</a><ul class='methods'><li data-type='method'><a href="SNComponentManager.html#deinit">deinit</a></li></ul></li><li><a href="SNEditor.html">SNEditor</a></li><li><a href="SNHistoryManager.html">SNHistoryManager</a></li><li><a href="SNHttpService.html">SNHttpService</a></li><li><a href="SNKeyManager.html">SNKeyManager</a><ul class='methods'><li data-type='method'><a href="SNKeyManager.html#clearLocalKeyState">clearLocalKeyState</a></li><li data-type='method'><a href="SNKeyManager.html#contentTypeUsesRootKeyEncryption">contentTypeUsesRootKeyEncryption</a></li><li data-type='method'><a href="SNKeyManager.html#getAccountKeyParams">getAccountKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKey">getRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyParams">getRootKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyWrapperKeyParams">getRootKeyWrapperKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNKeyManager.html#hasRootKeyWrapper">hasRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForDecryptionOfPayload">keyToUseForDecryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForEncryptionOfPayload">keyToUseForEncryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="SNKeyManager.html#removeRootKeyWrapper">removeRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#rootKeyNeedsUnwrapping">rootKeyNeedsUnwrapping</a></li><li data-type='method'><a href="SNKeyManager.html#setDeviceInterface">setDeviceInterface</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKey">setNewRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKeyWrapper">setNewRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#unwrapRootKey">unwrapRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#validateAccountPassword">validateAccountPassword</a></li><li data-type='method'><a href="SNKeyManager.html#validatePasscode">validatePasscode</a></li><li data-type='method'><a href="SNKeyManager.html#validateWrappingKey">validateWrappingKey</a></li></ul></li><li><a href="SNMaxItemPayload.html">SNMaxItemPayload</a></li><li><a href="SNModelManager.html">SNModelManager</a><ul class='methods'><li data-type='method'><a href="SNModelManager.html#addItem">addItem</a></li><li data-type='method'><a href="SNModelManager.html#createItem">createItem</a></li><li data-type='method'><a href="SNModelManager.html#getMasterCollection">getMasterCollection</a></li><li data-type='method'><a href="SNModelManager.html#insertItem">insertItem</a></li><li data-type='method'><a href="SNModelManager.html#insertItems">insertItems</a></li><li data-type='method'><a href="SNModelManager.html#setItemDirty">setItemDirty</a></li><li data-type='method'><a href="SNModelManager.html#setItemProperties">setItemProperties</a></li></ul></li><li><a href="SNNote.html">SNNote</a><ul class='methods'><li data-type='method'><a href="SNNote.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SNNote.html#initUUID">initUUID</a></li><li data-type='method'><a href="SNNote.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SNNote.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SNNote.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SNNote.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNNoteSFItem.html">SFItem</a></li><li><a href="SNNoteSNNoteSFItem.html">SFItem</a></li><li><a href="SNPrivilegesService.html">SNPrivilegesService</a><ul class='methods'><li data-type='method'><a href="SNPrivilegesService.html#actionRequiresPrivilege">actionRequiresPrivilege</a></li><li data-type='method'><a href="SNPrivilegesService.html#netCredentialsForAction">netCredentialsForAction</a></li></ul></li><li><a href="SNProtocolService.html">SNProtocolService</a><ul class='methods'><li data-type='method'><a href="SNProtocolService.html#compareRootKeys">compareRootKeys</a></li><li data-type='method'><a href="SNProtocolService.html#createBackupFile">createBackupFile</a></li><li data-type='method'><a href="SNProtocolService.html#decryptErroredItems">decryptErroredItems</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByDecryptingPayload">payloadByDecryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByEncryptingPayload">payloadByEncryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#setKeyManager">setKeyManager</a></li><li data-type='method'><a href="SNProtocolService.html#supportedVersions">supportedVersions</a></li></ul></li><li><a href="SNSavedServerItemPayload.html">SNSavedServerItemPayload</a></li><li><a href="SNSessionManager.html">SNSessionManager</a></li><li><a href="SNSingletonManager.html">SNSingletonManager</a><ul class='methods'><li data-type='method'><a href="SNSingletonManager.html#addObservers">addObservers</a></li><li data-type='method'><a href="SNSingletonManager.html#registerPredicate">registerPredicate</a></li></ul></li><li><a href="SNStorageService.html">SNStorageService</a><ul class='methods'><li data-type='method'><a href="SNStorageService.html#canDecryptWithKey">canDecryptWithKey</a></li><li data-type='method'><a href="SNStorageService.html#clearValues">clearValues</a></li><li data-type='method'><a href="SNStorageService.html#decryptStorage">decryptStorage</a></li><li data-type='method'><a href="SNStorageService.html#generatePersistenceValue">generatePersistenceValue</a></li><li data-type='method'><a href="SNStorageService.html#getAllRawPayloads">getAllRawPayloads</a></li><li data-type='method'><a href="SNStorageService.html#getPersistenceKey">getPersistenceKey</a></li><li data-type='method'><a href="SNStorageService.html#handleApplicationStage">handleApplicationStage</a></li><li data-type='method'><a href="SNStorageService.html#isStorageWrapped">isStorageWrapped</a></li><li data-type='method'><a href="SNStorageService.html#setInitialValues">setInitialValues</a></li></ul></li><li><a href="SNSyncService.html">SNSyncService</a><ul class='methods'><li data-type='method'><a href="SNSyncService.html#computeDataIntegrityHash">computeDataIntegrityHash</a></li><li data-type='method'><a href="SNSyncService.html#getDatabasePayloads">getDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#handleNeverSyncedDeleted">handleNeverSyncedDeleted</a></li><li data-type='method'><a href="SNSyncService.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNSyncService.html#loadDatabasePayloads">loadDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#markAllItemsAsNeedingSync">markAllItemsAsNeedingSync</a></li><li data-type='method'><a href="SNSyncService.html#payloadsByPreparingForServer">payloadsByPreparingForServer</a></li><li data-type='method'><a href="SNSyncService.html#popPayloadsNeedingPreSyncSave">popPayloadsNeedingPreSyncSave</a></li><li data-type='method'><a href="SNSyncService.html#popSpawnQueue">popSpawnQueue</a></li><li data-type='method'><a href="SNSyncService.html#repersistAllItems">repersistAllItems</a></li><li data-type='method'><a href="SNSyncService.html#resetSyncState">resetSyncState</a></li><li data-type='method'><a href="SNSyncService.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNSyncService.html#sync">sync</a></li><li data-type='method'><a href="SNSyncService.html#ut_beginLatencySimulator">ut_beginLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_endLatencySimulator">ut_endLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_setDatabaseLoaded">ut_setDatabaseLoaded</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayByDifference">arrayByDifference</a></li><li><a href="global.html#arrayByRemovingFromIndex">arrayByRemovingFromIndex</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#deepMerge">deepMerge</a></li><li><a href="global.html#DEFAULT_AUTO_SYNC_INTERVAL">DEFAULT_AUTO_SYNC_INTERVAL</a></li><li><a href="global.html#DEFAULT_ITEM_REVISIONS_THRESHOLD">DEFAULT_ITEM_REVISIONS_THRESHOLD</a></li><li><a href="global.html#extendArray">extendArray</a></li><li><a href="global.html#intentRequiresEncryption">intentRequiresEncryption</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_NONE">KEY_MODE_ROOT_KEY_NONE</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_ONLY">KEY_MODE_ROOT_KEY_ONLY</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_PLUS_WRAPPER">KEY_MODE_ROOT_KEY_PLUS_WRAPPER</a></li><li><a href="global.html#KEY_MODE_WRAPPER_ONLY">KEY_MODE_WRAPPER_ONLY</a></li><li><a href="global.html#LARGE_ENTRY_DELTA_THRESHOLD">LARGE_ENTRY_DELTA_THRESHOLD</a></li><li><a href="global.html#LAST_NONROOT_ITEMS_KEY_VERSION">LAST_NONROOT_ITEMS_KEY_VERSION</a></li><li><a href="global.html#lastElement">lastElement</a></li><li><a href="global.html#omitByCopy">omitByCopy</a></li><li><a href="global.html#PayloadsByAlternatingUuid">PayloadsByAlternatingUuid</a></li><li><a href="global.html#PayloadsByDuplicating">PayloadsByDuplicating</a></li><li><a href="global.html#pickByCopy">pickByCopy</a></li><li><a href="global.html#RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP">RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#removeFromIndex">removeFromIndex</a></li><li><a href="global.html#SortPayloadsByRecentAndContentPriority">SortPayloadsByRecentAndContentPriority</a></li><li><a href="global.html#StorageEncryptionPolicies">StorageEncryptionPolicies</a></li><li><a href="global.html#StoragePersistencePolicies">StoragePersistencePolicies</a></li><li><a href="global.html#StorageValueModes">StorageValueModes</a></li><li><a href="global.html#subtractFromArray">subtractFromArray</a></li><li><a href="global.html#ValueModesKeys">ValueModesKeys</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">services/protocol_service.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { PureService } from '@Lib/services/pure_service';
import { SNWebCrypto, isWebCryptoAvailable } from 'sncrypto';
import { Uuid } from '@Lib/uuid';
import {
  CreateEncryptionParameters,
  CreateIntentPayloadFromObject,
  CreateSourcedPayloadFromObject,
  CreateMaxPayloadFromAnyObject,
  PayloadSources,
  PayloadFormats,
  PayloadFields
} from '@Payloads';
import {
  isWebEnvironment,
  isString,
  isNullOrUndefined,
  isFunction
} from '@Lib/utils';
import {
  isDecryptedIntent,
  intentRequiresEncryption,
  SNProtocolOperator001,
  SNProtocolOperator002,
  SNProtocolOperator003,
  SNProtocolOperator004,
  CreateKeyParams,
  ProtocolVersions,
  EncryptionIntents
} from '@Protocol';

/**
 * The protocol service is responsible for the encryption and decryption of payloads, and
 * handles delegation of a task to the respective protocol operator. Each version of the protocol
 * (001, 002, 003, 004, etc) uses a respective operator version to perform encryption operations.
 * Operators are located in /protocol/operator.
 * The protocol service depends on the keyManager for determining which key to use for the 
 * encryption and decryption of a particular payload.
 * The protocol service is also responsible for dictating which protocol versions are valid,
 * and which are no longer valid or not supported.
 */
export class SNProtocolService extends PureService {
  constructor({ modelManager, crypto }) {
    if (!modelManager) {
      throw 'Invalid ProtocolService construction.';
    }
    super();
    this.operators = [];
    this.modelManager = modelManager;
    this.crypto = crypto;
    if (!this.crypto &amp;&amp; isWebEnvironment() &amp;&amp; isWebCryptoAvailable()) {
      /** IE and Edge do not support pbkdf2 in WebCrypto. */
      this.crypto = new SNWebCrypto();
    }
    Uuid.SetGenerators({
      syncImpl: this.crypto.generateUUIDSync,
      asyncImpl: this.crypto.generateUUIDSync
    });
  }

  /**
   * To avoid circular dependencies in constructor, applications must create
   * a key manager separately and feed it into the protocolService here.
   * @param keyManager  A fully constructed keyManager
   */
  setKeyManager(keyManager) {
    this.keyManager = keyManager;
  }

  setItemsKeyManager(itemsKeyManager) {
    this.keyObsUnsubscribe = itemsKeyManager.addItemsKeyChangeObserver(async () => {
      await this.decryptErroredItems();
    });
  }

  async deinit() {
    this.keyObsUnsubscribe();
    return super.deinit();
  }

  getLatestVersion() {
    return ProtocolVersions.V004;
  }

  async getUserVersion() {
    const keyParams = await this.keyManager.getRootKeyParams();
    return keyParams &amp;&amp; keyParams.version;
  }

  async upgradeAvailable() {
    return await this.getUserVersion() !== this.getLatestVersion();
  }

  supportsPasswordDerivationCost(cost) {
    /** 
     * Some passwords are created on platforms with stronger pbkdf2 capabilities, like 
     * iOS or WebCrypto, if user has high password cost and is using browser that doesn't 
     * support WebCrypto, we want to tell them that they can't login with this browser.
     */
    if (cost > 5000) {
      return this.crypto instanceof SNWebCrypto;
    } else {
      return true;
    }
  }

  /**
   * @returns  The versions that this library supports.
  */
  supportedVersions() {
    return [
      ProtocolVersions.V001,
      ProtocolVersions.V002,
      ProtocolVersions.V003,
      ProtocolVersions.V004,
    ];
  }

  isVersionNewerThanLibraryVersion(version) {
    const libraryVersion = this.getLatestVersion();
    return parseInt(version) > parseInt(libraryVersion);
  }

  isProtocolVersionOutdated(version) {
    // YYYY-MM-DD
    const expirationDates = {};
    expirationDates[ProtocolVersions.V001] = Date.parse('2018-01-01');
    expirationDates[ProtocolVersions.V002] = Date.parse('2020-01-01');

    const date = expirationDates[version];
    if (!date) {
      // No expiration date, is active version
      return false;
    }
    const expired = new Date() > date;
    return expired;
  }

  costMinimumForVersion(version) {
    switch (version) {
      case ProtocolVersions.V001:
        return SNProtocolOperator001.pwCost();
      case ProtocolVersions.V002:
        return SNProtocolOperator002.pwCost();
      case ProtocolVersions.V003:
        return SNProtocolOperator003.pwCost();
      case ProtocolVersions.V004:
        return SNProtocolOperator004.kdfIterations();
      default:
        throw `Unable to find cost minimum for version ${version}`;
    }
  }

  versionForPayload(payload) {
    return payload.content.substring(0, ProtocolVersions.VersionLength);
  }

  createOperatorForLatestVersion() {
    return this.createOperatorForVersion(this.getLatestVersion());
  }

  createOperatorForVersion(version) {
    if (version === ProtocolVersions.V001) {
      return new SNProtocolOperator001(this.crypto);
    } else if (version === ProtocolVersions.V002) {
      return new SNProtocolOperator002(this.crypto);
    } else if (version === ProtocolVersions.V003) {
      return new SNProtocolOperator003(this.crypto);
    } else if (version === ProtocolVersions.V004) {
      return new SNProtocolOperator004(this.crypto);
    } else if (version === ProtocolVersions.V000Base64Decrypted) {
      return this.createOperatorForLatestVersion();
    } else {
      throw `Unable to find operator for version ${version}`;
    }
  }

  operatorForVersion(version) {
    const operatorKey = version;
    let operator = this.operators[operatorKey];
    if (!operator) {
      operator = this.createOperatorForVersion(version);
      this.operators[operatorKey] = operator;
    }
    return operator;
  }

  defaultOperator() {
    return this.operatorForVersion(this.getLatestVersion());
  }

  async computeRootKey({ password, keyParams }) {
    const version = keyParams.version;
    const operator = this.operatorForVersion(version);
    return operator.computeRootKey({ password, keyParams });
  }

  async createRootKey({ identifier, password }) {
    const operator = this.defaultOperator();
    return operator.createRootKey({ identifier, password });
  }

  async getRootKeyParams() {
    return this.keyManager.getRootKeyParams();
  }

  payloadContentFormatForIntent({ key, intent }) {
    if (!key) {
      /** Decrypted */
      if ((
        intent === EncryptionIntents.LocalStorageDecrypted ||
        intent === EncryptionIntents.LocalStoragePreferEncrypted ||
        intent === EncryptionIntents.FileDecrypted ||
        intent === EncryptionIntents.FilePreferEncrypted
      )) {
        return PayloadFormats.DecryptedBareObject;
      } else if ((
        intent === EncryptionIntents.SyncDecrypted
      )) {
        return PayloadFormats.DecryptedBase64String;
      } else {
        throw `Unhandled decrypted case in protocolService.payloadContentFormatForIntent.`;
      }
    } else {
      /** Encrypted */
      if ((
        intent === EncryptionIntents.Sync ||
        intent === EncryptionIntents.FileEncrypted ||
        intent === EncryptionIntents.FilePreferEncrypted ||
        intent === EncryptionIntents.LocalStorageEncrypted ||
        intent === EncryptionIntents.LocalStoragePreferEncrypted
      )) {
        return PayloadFormats.EncryptedString;
      } else {
        throw `Unhandled encrypted case in protocolService.payloadContentFormatForIntent.`;
      }
    }
  }

  /**
   * Generates parameters for a payload that are typically encrypted, and used for syncing or saving locally.
   * Parameters are non-typed objects that can later by converted to objects.
   * @param key Optional. The key to use to encrypt the payload. Will be looked up if not supplied.
   * @returns A plain key/value object.
   */
  async payloadByEncryptingPayload({ payload, key, intent }) {
    if (payload.errorDecrypting) {
      return payload;
    }
    if (!key &amp;&amp; !isDecryptedIntent(intent)) {
      key = await this.keyManager.keyToUseForEncryptionOfPayload({ payload, intent });
    }
    if (!key &amp;&amp; intentRequiresEncryption(intent)) {
      throw 'Attempting to generate encrypted payload with no key.';
    }
    if (payload.getFormat() !== PayloadFormats.DecryptedBareObject) {
      throw 'Attempting to encrypt already encrypted payload.';
    }
    if (!payload.isPayload) {
      throw 'Attempting to encrypt non-payload.';
    }
    if (!payload.content) {
      throw 'Attempting to encrypt payload with no content.';
    }
    if (!payload.uuid) {
      throw 'Attempting to encrypt payload with no uuid.';
    }

    const version = key ? key.version : this.getLatestVersion();
    const format = this.payloadContentFormatForIntent({ key, intent });
    const operator = this.operatorForVersion(version);
    const encryptionParameters = await operator.generateEncryptionParameters({
      payload,
      key,
      format
    });
    if (!encryptionParameters) {
      throw 'Unable to generate encryption parameters';
    }
    return CreateIntentPayloadFromObject({
      object: payload,
      override: encryptionParameters,
      intent: intent
    });
  }

  async payloadsByEncryptingPayloads({ payloads, intent }) {
    const results = [];
    for (const payload of payloads) {
      const useIntent = isFunction(intent) ? intent(payload) : intent;
      const encryptedPayload = await this.payloadByEncryptingPayload({
        payload: payload,
        intent: useIntent
      });
      results.push(encryptedPayload);
    }
    return results;
  }

  /**
   * Generates a new payload by decrypting the input payload.
   * If the input payload is already decrypted, it will be returned as-is.
   * @param payload - The payload to decrypt.
   * @param key - Optional. The key to use to decrypt the payload. 
   *              If none is supplied, it will be automatically looked up.
   */
  async payloadByDecryptingPayload({ payload, key }) {
    if (!payload.content) {
      throw 'Attempting to decrypt payload that has no content.';
    }
    if (!payload.isPayload) {
      throw 'Attempting to decrypt non-payload.';
    }
    const format = payload.getFormat();
    if (format === PayloadFormats.DecryptedBareObject) {
      return payload;
    }
    if (!key &amp;&amp; format === PayloadFormats.EncryptedString) {
      key = await this.keyManager.keyToUseForDecryptionOfPayload({ payload });
      if (!key) {
        return CreateMaxPayloadFromAnyObject({
          object: payload,
          override: {
            waitingForKey: true,
            errorDecrypting: true
          }
        });
      }
    }
    const version = this.versionForPayload(payload);
    const operator = this.operatorForVersion(version);
    const encryptionParameters = CreateEncryptionParameters(payload);
    const decryptedParameters = await operator.generateDecryptedParameters({
      encryptedParameters: encryptionParameters,
      key: key
    });
    return CreateMaxPayloadFromAnyObject({
      object: payload,
      override: decryptedParameters
    });
  }

  async payloadsByDecryptingPayloads({ payloads, throws }) {
    const decryptedPayloads = [];

    for (const encryptedPayload of payloads) {
      if (!encryptedPayload) {
        /** Keep in counts similar to out counts */
        decryptedPayloads.push(encryptedPayload);
        continue;
      }

      if (!encryptedPayload.isPayload) {
        throw 'Attempting to decrypt non-payload object in payloadsByDecryptingPayloads.';
      }

      /**
       * We still want to decrypt deleted payloads if they have content in case
       * they were marked as dirty but not yet synced.
       */
      if (encryptedPayload.deleted === true &amp;&amp; isNullOrUndefined(encryptedPayload.content)) {
        decryptedPayloads.push(encryptedPayload);
        continue;
      }

      const isDecryptable = isString(encryptedPayload.content);
      if (!isDecryptable) {
        decryptedPayloads.push(encryptedPayload);
        continue;
      }

      try {
        const decryptedPayload = await this.payloadByDecryptingPayload({
          payload: encryptedPayload
        });
        decryptedPayloads.push(decryptedPayload);
      } catch (e) {
        decryptedPayloads.push(CreateMaxPayloadFromAnyObject({
          object: encryptedPayload,
          override: {
            [PayloadFields.ErrorDecrypting]: true,
            [PayloadFields.ErrorDecryptingChanged]: !encryptedPayload.errorDecrypting
          }
        }));
        if (throws) { throw e; }
        console.error("Error decrypting payload", encryptedPayload, e);
      }
    }

    return decryptedPayloads;
  }

  /**
   * If an item was attempting to decrypt, but failed, either because the keys
   * for that item had not downloaded yet, or any other reason, it will be deferred
   * item.errorDecrypting = true and possibly item.waitingForKey = true.
   * Here we find such items, and attempt to decrypt them again.
   */
  async decryptErroredItems() {
    const items = this.modelManager.allItems.filter((item) => {
      return item.waitingForKey || item.errorDecrypting;
    });
    if (items.length === 0) {
      return;
    }
    const payloads = items.map((item) => {
      return item.payloadRepresentation();
    });
    const decrypted = await this.payloadsByDecryptingPayloads({
      payloads
    });
    await this.modelManager.mapPayloadsToLocalItems({
      payloads: decrypted
    });
  }

  async payloadsByDecryptingBackupFile({ data, password }) {
    const keyParams = data.keyParams || data.auth_params;
    const rawItems = data.items;
    const encryptedPayloads = rawItems.map((rawItem) => {
      return CreateSourcedPayloadFromObject({
        object: rawItem,
        source: PayloadSources.FileImport,
      });
    });
    let decryptedPayloads;
    if (keyParams) {
      const key = await this.computeRootKey({
        password: password,
        keyParams: keyParams
      });
      decryptedPayloads = await this.payloadsByDecryptingPayloads({
        payloads: encryptedPayloads,
        key: key
      });
    } else {
      decryptedPayloads = encryptedPayloads;
    }
    return decryptedPayloads;
  }

  async payloadsByDecryptingRawPayload({ rawPayload }) {
    const encryptedPayload = CreateSourcedPayloadFromObject({
      object: rawPayload
    });
    return this.payloadByDecryptingPayload({
      payload: encryptedPayload
    });
  }

  /**
   * Compares two keys for equality
   * @returns Boolean
  */
  async compareRootKeys(keyA, keyB) {
    return keyA.compare(keyB);
  }

  createKeyParams(keyParams) {
    if (keyParams.isKeyParamsObject) {
      throw 'Attempting to create key params from non-raw value.';
    }
    /* 002 doesn't have version automatically, newer versions do. */
    if (!keyParams.version) {
      keyParams.version = ProtocolVersions.V002;
    }
    return CreateKeyParams(keyParams);
  }

  /**
   * Creates a JSON string representing the backup format of all items, or just subitems
   * if supplied.
   * @param {Array} subItems  An optional array of items to create backup of.
   *                       If not supplied, all items are backed up. 
   * @param {bool} returnIfEmpty Returns null if there are no items to make backup of.
   */
  async createBackupFile({ subItems, intent, returnIfEmpty } = {}) {
    const items = subItems || this.modelManager.allItems;
    if (returnIfEmpty &amp;&amp; items.length === 0) {
      return null;
    }
    if (!intent) {
      intent = EncryptionIntents.FilePreferEncrypted;
    }
    const payloads = items.map((item) => {
      return CreateMaxPayloadFromAnyObject({ object: item });
    });
    const encryptedPayloads = await this.payloadsByEncryptingPayloads({
      payloads: payloads,
      intent: intent
    });
    const data = {
      items: encryptedPayloads
    };
    const keyParams = await this.keyManager.getRootKeyParams();
    if (keyParams &amp;&amp; intent !== EncryptionIntents.FileDecrypted) {
      data.keyParams = keyParams.getPortableValue();
    }
    const prettyPrint = 2;
    return JSON.stringify(data, null, prettyPrint);
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Thu Feb 27 2020 12:31:59 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
